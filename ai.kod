1. InputManager'ı Güncelle
class InputManager {
    constructor() {
        this.keys = {};
        this.gameActions = {
            PADDLE_UP: ['ArrowUp', 'KeyW'],
            PADDLE_DOWN: ['ArrowDown', 'KeyS'],
            PAUSE: ['Space', 'Escape']
        };

        // Sürekli input için
        this.continuousActions = new Set();
        this.lastSentActions = new Set();

        this.setupEventListeners();
    }

    setupEventListeners() {
        document.addEventListener('keydown', (e) => {
            if (!this.keys[e.code]) { // İlk kez basıldığında
                this.keys[e.code] = true;

                // Oyun tuşlarının sayfa kaydırma vb. işlevlerini engelle
                if (this.isGameKey(e.code)) {
                    e.preventDefault();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            this.keys[e.code] = false;

            // Tuş bırakıldığında continuous action'ları temizle
            this.updateContinuousActions();
        });

        // Focus kaybında tüm tuşları serbest bırak
        window.addEventListener('blur', () => {
            this.keys = {};
            this.continuousActions.clear();
            this.lastSentActions.clear();
        });
    }

    isGameKey(keyCode) {
        return Object.values(this.gameActions).flat().includes(keyCode);
    }

    isActionActive(action) {
        return this.gameActions[action]?.some(key => this.keys[key]) || false;
    }

    updateContinuousActions() {
        this.continuousActions.clear();

        // Aktif olan action'ları ekle
        for (const [action, keys] of Object.entries(this.gameActions)) {
            if (keys.some(key => this.keys[key])) {
                this.continuousActions.add(action);
            }
        }
    }

    getContinuousActions() {
        this.updateContinuousActions();
        return Array.from(this.continuousActions);
    }

    // Hangi action'ların değiştiğini döndür
    getChangedActions() {
        this.updateContinuousActions();

        const current = this.continuousActions;
        const previous = this.lastSentActions;

        const started = [...current].filter(action => !previous.has(action));
        const stopped = [...previous].filter(action => !current.has(action));

        // Son gönderilen durumu güncelle
        this.lastSentActions = new Set(current);

        return { started, stopped, current: [...current] };
    }
}

export default InputManager;





2. Client.js'te Input Handling'i Güncelle
// ...existing code...
    handleInput() {
        const actionChanges = this.inputManager.getChangedActions();

        // Yeni başlayan action'lar
        actionChanges.started.forEach(action => {
            if (action === 'PADDLE_UP') {
                this.networkManager.send('paddle_move_start', { direction: 'up' });
            } else if (action === 'PADDLE_DOWN') {
                this.networkManager.send('paddle_move_start', { direction: 'down' });
            }
        });

        // Durdurulan action'lar
        actionChanges.stopped.forEach(action => {
            if (action === 'PADDLE_UP' || action === 'PADDLE_DOWN') {
                this.networkManager.send('paddle_move_stop', {});
            }
        });

        // Sürekli devam eden action'lar (optional - sadece gerekirse)
        // actionChanges.current.forEach(action => {
        //     if (action === 'PADDLE_UP') {
        //         this.networkManager.send('paddle_move_continuous', { direction: 'up' });
        //     } else if (action === 'PADDLE_DOWN') {
        //         this.networkManager.send('paddle_move_continuous', { direction: 'down' });
        //     }
        // });
    }

    gameLoop() {
        if (!this.isRunning) return;

        // Her frame'de input'u kontrol et
        this.handleInput();

        this.render();
        requestAnimationFrame(() => this.gameLoop());
    }
// ...existing code...



3. Alternatif: Interval-Based Approach
// ...existing code...
    constructor(canvasId) {
        // ...existing code...
        this.inputSendInterval = null;
        this.currentInputs = new Set();
    }

    handleInput() {
        const activeActions = this.inputManager.getContinuousActions();
        const currentSet = new Set(activeActions);

        // Input durumu değiştiyse
        if (!this.setsEqual(this.currentInputs, currentSet)) {
            this.currentInputs = currentSet;

            // Önceki interval'ı temizle
            if (this.inputSendInterval) {
                clearInterval(this.inputSendInterval);
                this.inputSendInterval = null;
            }

            if (this.currentInputs.size > 0) {
                // Hemen bir mesaj gönder
                this.sendCurrentInputs();

                // Sürekli gönderim başlat (örn: 60ms'de bir)
                this.inputSendInterval = setInterval(() => {
                    this.sendCurrentInputs();
                }, 60);
            } else {
                // Tüm input'lar durduysa stop mesajı gönder
                this.networkManager.send('paddle_move_stop', {});
            }
        }
    }

    sendCurrentInputs() {
        this.currentInputs.forEach(action => {
            if (action === 'PADDLE_UP') {
                this.networkManager.send('paddle_move', { direction: 'up' });
            } else if (action === 'PADDLE_DOWN') {
                this.networkManager.send('paddle_move', { direction: 'down' });
            }
        });
    }

    setsEqual(set1, set2) {
        if (set1.size !== set2.size) return false;
        for (let item of set1) {
            if (!set2.has(item)) return false;
        }
        return true;
    }

    destroy() {
        if (this.inputSendInterval) {
            clearInterval(this.inputSendInterval);
        }
        // ...existing cleanup...
    }
// ...existing code...




4. Server-Side Mesaj Türleri
// server/server.js
socket.on('message', (data) => {
    const message = JSON.parse(data.toString());

    switch(message.type) {
        case 'paddle_move_start':
            // Oyuncunun paddle'ını sürekli hareket ettirmeye başla
            startContinuousMovement(playerId, message.payload.direction);
            break;

        case 'paddle_move_stop':
            // Oyuncunun paddle hareketini durdur
            stopContinuousMovement(playerId);
            break;

        case 'paddle_move':
            // Anlık paddle hareketi (interval approach için)
            movePaddle(playerId, message.payload.direction);
            break;
    }
});
